---
title: 'Image Classification AI API with Docker and Cloud Deployment'
date: '2025-08-15'
tags: ['AI', 'FastAPI', 'Docker', 'GCP']
summary: 'Build an image classification AI model API, package it with Docker, and deploy it to the cloud.'
draft: false
---

## 1. The Story Behind the Project

In the past, I had some experience about AI project, including image recognition and NLP, but all of them were just code.  
Through this project, I would like to learn how to make my work be like a real product.

This project was designed to:

- Showcase full-stack MLOps skills (Model ‚Üí API ‚Üí Docker ‚Üí Cloud)

---

## 2. Tech Stack

This project uses the following technologies:

- **PyTorch** ‚Äî Deep learning library used to train a digit recognition model (MNIST)
- **FastAPI** ‚Äî Python web framework for building APIs
- **Docker** ‚Äî To containerize the application
- **GCP Cloud Run** ‚Äî For serverless container deployment
- **GCP Artifact Registry** ‚Äî To store Docker images

---

## 3. Step-by-Step Implementation with explaination

### Getting Started

#### 1. Start python virtual environment

Use python virtual environment to make sure that the local environment would be clean.

```bash
python -m venv venv
.\venv\Scripts\activate
```

#### 2. Install Dependencies

```bash
pip install -r requirements.txt
```

#### 3. Train Model

```bash
python -m train.train_model
```

#### 4. Run the API locally (Optional)

Used to start Uvicorn, a Python ASGI server, to run the FastAPI application.

```bash
uvicorn app.main:app --reload
```

Open the Swagger UI for interactive testing:  
üëâ http://127.0.0.1:8000/docs

<img src="/static/images/SwaggerUI.png" alt="Swagger UI" width="800" height="600" />

---

### Example Usage

#### POST `/predict`

**Input JSON:**

```json
{
  "image_base64": "iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAAAAABXZoBIAAAA6ElEQVR4nGNgGMyAWUhIqK5jvdSy/9/rQXwWmIQcm5WNQDCI9WRS4OeLB0EsRqic4V5+KOtf0leGZ+9vIpsodPsvCBzb9v0jFvsC5mT//XuWm0F7FjbX8DHO+huFKsQEZ336/5EhBcFFB9z7/rrh9qfyx4cLcmDuxwCBH/7+LZfEJau76+/fadK4ZAVi//zdjdvin39/OkCZLKgyeiGmLAzXDmHTpD7l6d+/f39twyIlUXQXFLwn/TClxJ2ugkM+EDOQhFaDY+VwACeGlPmaRyCpL63cqOJg1wYGMjBc3/y35wNuD1ITAABFF16AbmkxawAAAABJRU5ErkJggg=="
}
```

**Response:**

```json
{
  "prediction": 5
}
```

---

### Docker Deployment

#### 1. Install Docker Desktop

Official Website: https://www.docker.com/products/docker-desktop/

### 2. Create Dockerfile and .dockerignore

There are already a Dickerfile and .dockerignore in the repositery.

- Dockerfile is used to define and create a Docker image.
- .dockerignore is used to ignore something we don't want to pack.

### 3. Build Docker Image

docker build is the command to create a Docker image.

- -t is the name of docker image.
- . is the current working path.

```bash
docker build -t mnist-api .
```

### 4. Run Docker Locally (Optional)

docker run is the command to run a new container.

- Use the previously built image mnist-api to start a new container and set up port mapping.
- -p 8000:8080 is Port mapping, the left port is on the host machine and the right port is inside the container.
- mnist-api is the used image.

```bash
docker run -p 8000:8080 mnist-api
```

---

## Deploy to Google Cloud Run

### 1. Install gcloud CLI (Google Cloud SDK)

Office Website: https://cloud.google.com/sdk/docs/install

### 2. Prerequisite

login google account

```bash
gcloud auth login
```

Initialization GCP project and area

```bash
gcloud init
```

Set specific project and area

```bash
gcloud config set project mnist-api-469005
gcloud config set run/region asia-east1
```

Enable Cloud Run and Artifact Registry API

- Artifact Registry is a repository for storing Docker images

```bash
gcloud services enable run.googleapis.com artifactregistry.googleapis.com
```

### 3. Verify if login and project setup are successful (Optional)

check the current account

```bash
gcloud auth list
```

check the current project

```bash
gcloud config list project
```

### 4. Deployment

The project information:

- The Dockerfile is located in the project root directory
- GCP Project IDÔºömnist-api-469005
- RegionÔºöasia-east1
- Artifact Repo nameÔºömnist-repo
- Image nameÔºömnist-api

Create Artifact Registry  
Artifact Registry is only created once, so we can push the new version image without excuting this cmd again

```bash
gcloud artifacts repositories create mnist-repo --repository-format=docker --location=asia-east1 --project=mnist-api-469005 --description="MNIST API Repo"
```

Login Docker with GCP  
Configure Docker credentials to authorize image uploads to GCP's Artifact Registry.

```bash
gcloud auth configure-docker asia-east1-docker.pkg.dev
```

Upload the current directory (including the Dockerfile and code) to Google Cloud Build, where the image is built on Google‚Äôs servers and then automatically push to the specified Artifact Registry.

```bash
gcloud builds submit --tag asia-east1-docker.pkg.dev/mnist-api-469005/mnist-repo/mnist-api
```

Deploy Docker image to Cloud Run

```bash
gcloud run deploy mnist-api --image=asia-east1-docker.pkg.dev/mnist-api-469005/mnist-repo/mnist-api --platform=managed --region=asia-east1 --allow-unauthenticated --project=mnist-api-469005 --memory=1Gi
```

Once deployed, you‚Äôll get a public endpoint like:

```
https://mnist-api-xxxxx.a.run.app/predict
```

### Test

#### Method 1

Use Swagger UI.  
The URL would be https://mnist-api-xxxxx.a.run.app/predict/docs
Use the previous Example Usage for input.

#### Method 2

Use Windows cmd line.

```bash
curl -X POST https://mnist-api-xxxxx.a.run.app/predict ^
  -H "Content-Type: application/json" ^
  -d "{\"image_base64\": \"iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAAAAABXZoBIAAAA6ElEQVR4nGNgGMyAWUhIqK5jvdSy/9/rQXwWmIQcm5WNQDCI9WRS4OeLB0EsRqic4V5+KOtf0leGZ+9vIpsodPsvCBzb9v0jFvsC5mT//XuWm0F7FjbX8DHO+huFKsQEZ336/5EhBcFFB9z7/rrh9qfyx4cLcmDuxwCBH/7+LZfEJau76+/fadK4ZAVi//zdjdvin39/OkCZLKgyeiGmLAzXDmHTpD7l6d+/f39twyIlUXQXFLwn/TClxJ2ugkM+EDOQhFaDY+VwACeGlPmaRyCpL63cqOJg1wYGMjBc3/y35wNuD1ITAABFF16AbmkxawAAAABJRU5ErkJggg==\"}"
```

The answer is 5.

<img src="/static/images/test_curl.png" alt="test_curl UI" width="600" height="200" />

---

## 4. Gotchas & Debugging

Here are some real issues I encountered:

- ‚ùå **.dockerignore doesn't work** ‚Äî I already add `venv/` in .dockerignore, but it didn't work. And then I delete the venv file directly.
- ‚ùå **Out-of-memory error** ‚Äî default 512 MiB was too small for this cmd (gcloud run deploy); increased to 1GiB
- ‚ùå **Incorrect base64 input** ‚Äî not using proper grayscale-encoded MNIST images

Each of these taught me something about deployment pipelines!

---

## 5. Future Improvements & Extensions

This was just a start. Possible extensions:

- üì¶ Add support for image file uploads (not just base64)
- üß† Swap in more advanced models (ResNet, YOLO, etc.)
- üîÅ Add CI/CD using GitHub Actions to auto-deploy on push
- üåç Add frontend for real-time predictions (React/Streamlit)

---

## 6. Conclusion

This side project helped me:

- Practice full-stack MLOps deployment
- Document a clean, working GitHub portfolio project
- Learn Docker, GCP, and FastAPI in a real-world context

### GitHub Repository

[üëâ View on GitHub](https://github.com/ChengZheWu/Image-Classification-AI-API-with-Docker-and-Cloud-Deployment)

---

## Appendix

### FastAPI Introduction

FastAPI is a modern, high-performance web framework written in Python. It is built on top of Starlette and Pydantic, and is primarily used to build API applications‚Äîespecially RESTful APIs.

- Starlette: An asynchronous web framework that provides the underlying web handling capabilities.
- Pydantic: A Python library for data validation and parsing. It is mainly used to define data models, validate input formats, and perform automatic type conversion.
- RESTful API: An API that follows the REST (Representational State Transfer) architectural style. It is commonly used in web applications to enable communication between clients and servers over HTTP.

FastAPI automatically generates a Swagger UI for interactive testing.

#### Design the /predict Route

The purpose is to receive a handwritten picture with a base64 format, and then use our model to predict the result.

Analyse app/main.py

```
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from app.predict import predict_digit

app = FastAPI()

class PredictRequest(BaseModel):
    image_base64: str

@app.post("/predict")
def predict(req: PredictRequest):
    try:
        result = predict_digit(req.image_base64)
        return {"prediction": result}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

@app.post is a route decorator in FastAPI. When a POST request is sent to the /predict path, FastAPI will call the predict() function defined below to handle the request

- /predict is the route path.
- The request body contains an image encoded in Base64 format, which is simple and widely supported.
- FastAPI uses Pydantic to define the data schema for the request body.
- Base64 is an encoding method that converts binary data into plain text.
- The function returns a response in a specified format.

### Docker Introduction

Docker is an open-source containerization platform that packages all the libraries, configurations, and resources of an application into a container. This ensures the container can run consistently across different environments.  
In this implementation, we use Docker Desktop, a graphical toolkit that integrates the Docker Engine, a container management GUI, the Docker CLI, and automatic WSL2 installation. It's ideal for beginners who want to get started quickly, especially those using Windows or macOS and prefer a graphical interface.

#### Dockerfile

Dockerfile is used to define and create a Docker image

There are 4 layers in a Dockerfile.

1. Base image: Something like python:3.10-slim or ubuntu:22.04, which already comes with the operating system and environment prepared for you.
2. Dependency layer: The packages you install using commands like RUN pip install ....
3. Application layer: Your source code and configuration.
4. Top layer: The settings executed when the container starts (e.g., CMD).

```dockerfile
# 1. choose a base image
FROM python:3.10-slim

# 2. Set the working directory inside the container
WORKDIR /app

# 3. Copy the local files to the container, such as code or requirements.txt
COPY ./app ./app
COPY ./model ./model
COPY requirements.txt ./

# 4. Excute a command (Usually used to install packages)
RUN pip install --no-cache-dir -r requirements.txt

# 5. declare the port that container usesÔºàjust explanationÔºâ
EXPOSE 8080

# 6. The command to run when the container starts. Only one CMD in a Dockerfile
#    Run app from main.py using Uvicorn, with the host set to 0.0.0.0 and the port set to 8080, making it accessible from outside.
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8080"]
```

#### .dockerignore

Ignore somethings we don't want to pack.  
Just write down the path of the file directly.

```
__pycache__/
venv/
```

### Google Cloud Platform

GCP (Google Cloud Platform) is Google's cloud platform that supports everything from infrastructure services like virtual machines (VMs) to modern cloud-native solutions such as Kubernetes, Cloud Run, and AI Platform. It enables developers to quickly deploy and scale applications.

#### Artifact Registry

Store the image we built using Docker

#### Cloud Run

A serverless deployment service for Docker containers.

- Automatic scaling based on incoming requests
- Supports HTTP triggers, making it ideal for APIs
- Pay-as-you-go pricing, with near-zero cost at low traffic
  In this project, the FastAPI app is packaged into a Docker image and deployed to Cloud Run using this cmd gcloud run deploy

---

If you found this useful or want to share feedback, feel free to open an issue or reach out!  
Happy coding!
